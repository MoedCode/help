from django.contrib import admin

# Register your models here.
from django.apps import AppConfig


class ApiConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'api'
from rest_framework import status as S
from rest_framework import status
# from api.models import Classes, classes

S200 = S.HTTP_200_OK
S201 = S.HTTP_201_CREATED
S304 = S.HTTP_304_NOT_MODIFIED
S400 = S.HTTP_400_BAD_REQUEST
S401 = S.HTTP_401_UNAUTHORIZED
S405 = S.HTTP_405_METHOD_NOT_ALLOWED
S403 = S.HTTP_403_FORBIDDEN
S404 = S.HTTP_404_NOT_FOUND
S405 = S.HTTP_405_METHOD_NOT_ALLOWED
S406 = S.HTTP_406_NOT_ACCEPTABLE
S408 = S.HTTP_408_REQUEST_TIMEOUT
S500 = S.HTTP_500_INTERNAL_SERVER_ERROR

from datetime import datetime
from django.utils import timezone
import uuid
from django.db import models
from django.contrib.auth.models import AbstractUser
time_format = "%Y-%m-%dT%H:%M:%S.%f"

time_format = "%Y-%m-%d %H:%M:%S"  # Format: YYYY-MM-DD HH:MM:SS

class Base(models.Model):
    """Base model with common fields."""
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    created_date = models.DateTimeField(default=timezone.now, editable=False)  # ✅ Immutable, defaults to now
    updated_date = models.DateTimeField(auto_now=True)  # ✅ Auto-updates on modification

    class Meta:
        abstract = True  # ✅ Ensures Django doesn't create a `Base` table

    def to_save(self, *args, **kwargs):
        """Prevent modification of created_date"""
        if self.pk:  # If object exists, prevent modification of created_date
            old_instance = self.__class__.objects.get(pk=self.pk)
            self.created_date = old_instance.created_date  # Keep original value
        super().save(*args, **kwargs)

    def to_dict(self):
        """Convert model instance to dictionary, formatting date fields."""
        new_dict = self.__dict__.copy()
        new_dict['id'] = str(new_dict['id'])
        new_dict['created_date'] = self.created_date.strftime(time_format)
        new_dict['updated_date'] = self.updated_date.strftime(time_format)
        new_dict.pop('_state', None)  # Remove internal Django state

        if 'date_joined' in new_dict:
            new_dict['date_joined'] = new_dict['date_joined'].strftime(time_format)

        if 'user_id' in new_dict:
            new_dict['user_id'] = str(new_dict['user_id'])

        return new_dict

    def inttant_serializer(self):
        """Convert instance to dictionary but hide sensitive fields."""
        serialized = self.to_dict()
        for field in ["password", "created_date", "updated_date"]:
            serialized.pop(field, None)  # ✅ Safely remove sensitive fields
        return serialized

class Users(AbstractUser, Base):
    """Custom user model that inherits from AbstractUser and Base."""

    email = models.EmailField(unique=True, blank=False)
    first_name = models.CharField(max_length=100, blank=False)
    last_name = models.CharField(max_length=100, blank=False)

    # group = models.ForeignKey(Groups, on_delete=models.SET_NULL, null=True, blank=True, related_name='members')
    group = models.ForeignKey("api.Groups", on_delete=models.SET_NULL, null=True, blank=True, related_name="user_groups")


    # New fields
    mobile_number = models.CharField(max_length=15, unique=True, blank=False, null=True)
    date_of_birth = models.DateField(null=True, blank=True)

    # Address fields (separate from Locations)
    street = models.CharField(max_length=255, null=True, blank=True)
    city = models.CharField(max_length=100, null=True, blank=True)
    country = models.CharField(max_length=100, null=True, blank=True)

    # User's last known location
    # location = models.OneToOneField(Locations, on_delete=models.SET_NULL, null=True, blank=True, related_name="user")
    location = models.ForeignKey("api.Locations", on_delete=models.SET_NULL, null=True, blank=True, related_name="user_location")

    REQUIRED_FIELDS = ["email", "first_name", "last_name", "mobile_number"]

    def __str__(self):
        return self.username
class Locations(Base):
    """Model to store location details and associate it with a user."""

    user = models.ForeignKey("api.Users", on_delete=models.CASCADE, related_name="user_location")
    latitude = models.DecimalField(max_digits=9, decimal_places=6, null=True, blank=True)
    longitude = models.DecimalField(max_digits=9, decimal_places=6, null=True, blank=True)
    address = models.CharField(max_length=255, null=True, blank=True)
    city = models.CharField(max_length=100, null=True, blank=True)
    country = models.CharField(max_length=100, null=True, blank=True)
    @classmethod
    def recent(cls, user_id, date_attr_name="updated_date"):
        """
        Get the most recent location for the given user_id based on updated_at timestamp.
        """
        if "updated" in date_attr_name:
            return cls.objects.filter(user_id=user_id).order_by("-updated_date").first()

        if "created" in date_attr_name:
            return cls.objects.filter(user_id=user_id).order_by("-created_date").first()

    def __str__(self):
        return f"Locations of {self.user.username} - {self.address or f'{self.latitude}, {self.longitude}'}"


class Groups(Base):
    """Groups that users can belong to."""
    name = models.CharField(max_length=255, unique=True)
    description = models.TextField(null=True, blank=True)

    admin_user = models.ForeignKey(
        Users, on_delete=models.CASCADE, related_name="admin_groups"
    )

    # members = models.ManyToManyField(Users, related_name="groups", blank=True)
    members = models.ManyToManyField("api.Users", related_name="user_groups")

    def add_member(self, user):
        """Admin can add users to the group."""
        if user not in self.members.all():
            self.members.add(user)

    def remove_member(self, user):
        """Admin can remove users from the group."""
        if user in self.members.all():
            self.members.remove(user)

    def assign_new_admin(self, new_admin):
        """Admin can assign another user as the admin."""
        if new_admin in self.members.all():
            self.admin_user = new_admin
            self.save()

    def user_exit(self, user):
        """Allows a user to leave the group, transferring admin if needed."""
        if user == self.admin_user:
            members = list(self.members.all())  # Get all members
            if members:  # If other users exist, assign first member as admin
                self.admin_user = members[0]
            else:  # If no members left, delete the group
                self.delete()
                return
        self.members.remove(user)
        self.save()

    def __str__(self):
        return f"{self.name} (Admin: {self.admin_user.username})"
class GroupContact(models.Model):
    """Tracks a user's membership in a group with a custom nickname."""

    user = models.ForeignKey(
        "api.Users",
        on_delete=models.SET_NULL,  # Set to NULL instead of deleting the GroupMember instance
        null=True,
        blank=True,
        related_name="group_memberships"
    )
    group = models.ForeignKey(
        "api.Groups",
        on_delete=models.CASCADE,  # If the group is deleted, delete all memberships
        related_name="group_members"
    )
    contact_name = models.CharField(max_length=255, unique=True, blank=True, null=True)  # Custom name in this group

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=["user", "group"],
                name="unique_user_in_group",
            )
        ]


    def __str__(self):
        if self.user:
            return f"{self.nickname or self.user.username} in {self.group.name}"
        return f"Deleted Account in {self.group.name}"  # If the user is deleted


class Profile(Base):
    user = models.OneToOneField(Users, on_delete=models.CASCADE)
    bio = models.TextField(blank=True)
    profile_image = models.ImageField(
        upload_to="profile_images",
        default="profile_images/blank-profile-picture.png",
    )
    profession = models.CharField(max_length=100, blank=True)
    location = models.CharField(max_length=100, blank=True)
    verified = models.BooleanField(default=False)



    def __str__(self):
        return self.user.username



class HelpRequest(Base):
    """Help request from a user, sent to other users in the same group."""
    user = models.ForeignKey(Users, on_delete=models.CASCADE, related_name='help_requests')
    group = models.ForeignKey(Groups, on_delete=models.CASCADE, related_name='help_requests')
    location = models.ForeignKey(Locations, on_delete=models.SET_NULL, null=True, blank=True, related_name="help_requests")
    description = models.TextField()
    request_date = models.DateTimeField(auto_now_add=True)
    is_resolved = models.BooleanField(default=False)

    def __str__(self):
        return f"Help Request from {self.user.username} in {self.group.name}"


class Message(Base):
    """Model to handle user-to-user messaging."""
    sender = models.ForeignKey(Users, on_delete=models.CASCADE, related_name='sent_messages')
    receiver = models.ForeignKey(Users, on_delete=models.CASCADE, related_name='received_messages')
    message_text = models.TextField()
    timestamp = models.DateTimeField(auto_now_add=True)
    is_read = models.BooleanField(default=False)

    def __str__(self):
        return f"Message from {self.sender.username} to {self.receiver.username} at {self.timestamp}"

class SubscriptionPackage(Base):
    """Subscription package model for different subscription plans."""
    name = models.CharField(max_length=255, unique=True)
    description = models.TextField(blank=True, null=True)
    price = models.DecimalField(max_digits=10, decimal_places=2)  # Subscription cost
    duration_days = models.PositiveIntegerField()  # Duration in days (e.g., 30 for monthly, 365 for yearly)

    created_by = models.ForeignKey(
        "api.Users",  # String reference to avoid circular imports
        on_delete=models.CASCADE,
        related_name="created_packages",
        limit_choices_to={'is_superuser': True},  # Ensures only superusers (admins) can create packages
    )

    def __str__(self):
        return f"{self.name} - ${self.price} ({self.duration_days} days)"


class UserSubscription(Base):
    """User subscription model to track which users have which subscriptions."""
    user = models.ForeignKey(
        "api.Users",  # String reference to avoid circular imports
        on_delete=models.CASCADE,
        related_name="subscriptions"
    )
    package = models.ForeignKey(
        "api.SubscriptionPackage",  # String reference to SubscriptionPackage
        on_delete=models.CASCADE,
        related_name="user_subscriptions"
    )
    start_date = models.DateTimeField(default=timezone.now)
    end_date = models.DateTimeField()  # Expiry date based on package duration

    def save(self, *args, **kwargs):
        """Automatically calculate end date based on package duration before saving."""
        if not self.end_date:
            self.end_date = self.start_date + timezone.timedelta(days=self.package.duration_days)
        super().save(*args, **kwargs)

    def __str__(self):
        return f"{self.user.username} subscribed to {self.package.name} until {self.end_date.strftime('%Y-%m-%d')}"

class UserConnections(Base):
    """Model to store user connections, including joined groups and trusted contacts."""
    user = models.ForeignKey(
        "api.Users",  # Reference to the user who owns these connections
        on_delete=models.CASCADE,
        related_name="connections"
    )
    group_name = models.CharField(max_length=255, blank=True, null=True)  # Name of the joined group
    contact_name = models.CharField(max_length=255)  # Name of the trusted contact
    phone_number = models.CharField(max_length=20, blank=True, null=True)  # Primary phone number
    additional_phone_numbers = models.JSONField(blank=True, null=True)  # Store multiple phone numbers as JSON
    email = models.EmailField(blank=True, null=True)  # Contact's email
    address = models.TextField(blank=True, null=True)  # Optional address field
    notes = models.TextField(blank=True, null=True)  # Additional notes for the contact

    def __str__(self):
        return f"{self.user.username}'s Contact: {self.contact_name} ({self.phone_number})"

class VerificationCode(Base):
    """Model to store verification codes with expiration."""
    user = models.ForeignKey(
        "api.Users",  # String reference to avoid circular import
        on_delete=models.CASCADE,
        related_name="verification_codes"
    )
    code = models.CharField(max_length=6)  # Six digits code
    is_used = models.BooleanField(default=False)
    expire_date = models.DateTimeField()

    def save(self, *args, **kwargs):
        """Generate code automatically if not provided and set expiration date."""
        if not self.code:
            self.code = str(uuid.uuid4().int)[:6]  # Random 6 digit code
        if not self.expire_date:
            self.expire_date = timezone.now() + timezone.timedelta(minutes=30)  # Set expiration after 5 mins
        super().save(*args, **kwargs)

    def is_valid(self):
        """Check if the code is valid and not expired."""
        return not self.is_used and self.expire_date > timezone.now()

    def __str__(self):
        return f"Verification Code {self.code} for {self.user.username}"
    @classmethod
    def clear_codes(cls, user=None, code=None, clear_all=False):
        """
        Clear expired codes:
        - By user
        - By specific code
        - Clear all expired codes
        """
        if not user and not clear_all and not code:
            raise ValueError("You must provide user, code, or set clear_all=True")

        if code:
            try:
                specific_code = cls.objects.get(code=code)
                if specific_code.expire_date < timezone.now() and not specific_code.is_used:
                    specific_code.delete()
                    return f"Verification code {code} deleted."
                else:
                    return "Code is not expired or already used."
            except cls.DoesNotExist:
                return "Verification code not found."

        if user:
            expired_codes = cls.objects.filter(user=user, expire_date__lt=timezone.now(), is_used=False)
        elif clear_all:
            expired_codes = cls.objects.filter(expire_date__lt=timezone.now(), is_used=False)
        else:
            expired_codes = cls.objects.none()

        count = expired_codes.delete()
        return f"{count[0]} expired codes deleted."
Classes = {
    "Users":Users,
    "Profile":Profile,
    "Locations":Locations,
    "Groups":Groups,
    "HelpRequest":HelpRequest,
    "Message":Message,
    "SubscriptionPackage":SubscriptionPackage,
    "UserSubscription":UserSubscription,
    "UserConnections":UserConnections,
}
classes = {
    "users":Users,
    "profile":Profile,
    "locations":Locations,
    "groups":Groups,
    "helpRequest":HelpRequest,
    "message":Message,
    "subscription_package":SubscriptionPackage,
    "user_subscription":UserSubscription,
    "user_connections":UserConnections,
}from rest_framework import serializers
from api.models import *

class UsersSerializerAll(serializers.ModelSerializer):
    class Meta:
        model = Users
        fields = "__all__"
class UsersSerializer(serializers.ModelSerializer):
    class Meta:
        model = Users
        fields = ["username", "email", "first_name", "last_name", "id"]
        # fields = "__all__"



class ProfileSerializer(serializers.ModelSerializer):
    class Meta:
        model = Profile

        fields = "__all__"

class LocationsSerializer(serializers.ModelSerializer):
    class Meta:
        model = Locations

        fields = "__all__"
class GroupsSerializer(serializers.ModelSerializer):
    class Meta:
        model = Groups

        fields = "__all__"

class SubscriptionPackagesSerializer(serializers.ModelSerializer):
    class Meta:
        model = SubscriptionPackage

        fields = ["name","description","price","duration_days"]
class UserSubscriptionSerializer(serializers.ModelSerializer):
    class Meta:
        model = UserSubscription

        fields = "__all__"
class MessageSerializer(serializers.ModelSerializer):
    class Meta:
        model = Message

        fields = "__all__"
class HelpRequestSerializer(serializers.ModelSerializer):
    class Meta:
        model = HelpRequest

        fields = "__all__"
classesSerializers = {
    "users":UsersSerializer,
    "users_all":UsersSerializerAll,
    "profile":ProfileSerializer,
    "locations":LocationsSerializer,
    "groups":GroupsSerializer,
    "help_request":HelpRequestSerializer,
    "message":MessageSerializer,
    "Subscription_packages":SubscriptionPackagesSerializer,
    "user_Subscription":UserSubscriptionSerializer,

}from django.test import TestCase

# Create your tests here.
from django.urls import path
from . import views

urlpatterns = [
    path("", views.Hi.as_view(), name="about"),
    path("csrf", views.getCSRFCookie.as_view(), name="csrf"),
                        #Users URL's
    path("register/", views.Register.as_view(), name="resgister"),
    path("delete_user/", views.DeleteUser.as_view(), name="delete_user"),
    path("login/", views.Login.as_view(), name="login"),
    path("logout/", views.Logout.as_view(), name="logout"),
    path("login/", views.Login.as_view(), name="login"),
    path("user_data/", views.GetUserData.as_view(), name="user_data"),
    path("user_update/", views.UserUpdate.as_view(), name="user_update"),
    path("activate/", views.ActivateAccount.as_view(), name="activate"),
    path("get_code/", views.GetVerificationCode.as_view(), name="get_code"),


                        #Profile URL's
    path("profile_view/", views.ProfileView.as_view(), name="profile_view"),
    path("profile_update/", views.ProfileUpdate.as_view(), name="profile_update"),

                        #Groups URL's
    # path("user_members/<str:group_ID>", views.GroupMembersData.as_view(), name="user_members"),
    path("group_members/", views.GroupMembersData.as_view(), name="group_members"),
    path("user_groups/", views.GetUserGroups.as_view(), name="user_groups"),
    path("create_group/", views.CreateGroup.as_view(), name="create_group"),
    path("update_group/", views.UpdateGroup.as_view(), name="update_group"),
    path("add_user_to_group/", views.AddUserToGroup.as_view(), name="add_user_to_group"),
    path("remove_user_from_group/", views.RemoveUserFromGroup.as_view(), name="remove_user_from_group"),
    path("get_group_contacts/", views.GetUpdateGroupContacts.as_view(), name="get_group_contacts"),

                        # Location URL's
    path("set_location/", views.SetLocations.as_view(), name="set_location"),
    path("set_location/<str:id>/", views.SetLocations.as_view(), name="set_location_detail"),
    path("get_locations/", views.SetLocations.as_view(), name="get_locations"),
    path("get_location/", views.RecentLcation.as_view(), name="get_locations"),
    path("update_location/", views.SetLocations.as_view(), name="update_location"),
    path("delete_location/<str:id>/", views.SetLocations.as_view(), name="delete_location"),
    path("delete_location/", views.SetLocations.as_view(), name="delete_location"),
    path("delete_all_locations/", views.DeleteAllLocations.as_view(), name="delete_all_locations"),
    path("subscription/", views.SubscriptionPackageView.as_view(), name="subscription"),
                        # HELP request
    path("help/<str:msg>", views.SendHelpToGroupMembers.as_view(), name="help"),
    path("help/", views.SendHelpToGroupMembers.as_view(), name="help2"),
    path("send/", views.SendEmailToTest.as_view(), name="send"),
    path('send-sms/', views.SendSMSView.as_view(), name='send-sms'),
                        # echo request
    path("echo_request/", views.EchoRequestView.as_view(), name="echo_request"),
]# utils.py
from twilio.rest import Client
from django.conf import settings

def send_sms(to_phone_number, message):
    client = Client(settings.TWILIO_ACCOUNT_SID, settings.TWILIO_AUTH_TOKEN)

    try:
        message = client.messages.create(
            body=message,
            from_=settings.TWILIO_PHONE_NUMBER,
            to=to_phone_number
        )
        return {"status": "success", "message_sid": message.sid}
    except Exception as e:
        return {"status": "error", "error": str(e)}
import re
from datetime import date
from django.core.exceptions import ValidationError
from api.models import Users  # Import the Users model
import pycountry
from geopy.geocoders import Nominatim
from rest_framework.exceptions import ValidationError
import pycountry
from geopy.geocoders import Nominatim

def validate_user_data(request_data):
    """
    Validates user data from the request before creating a Users instance.
    - Ensures only valid fields are provided.
    - Validates required fields and data format.
    """

    # Get all valid field names from the Users model (excluding inherited ones)
    valid_fields = {field.name for field in Users._meta.get_fields() if not field.is_relation}

    # Check for extra keys in request data
    extra_keys = set(request_data.keys()) - valid_fields
    if extra_keys:
        raise ValidationError({"extra_keys": f"Invalid fields found: {', '.join(extra_keys)}"})

    # Check for missing required fields
    required_fields = {"email", "first_name", "last_name", "mobile_number", "password"}
    missing_fields = required_fields - request_data.keys()
    if missing_fields:
        raise ValidationError({"missing_fields": f"Missing required fields: {', '.join(missing_fields)}"})

    # Validate password (must be at least 8 characters)
    password = request_data.get("password", "")
    if len(password) < 8:
        raise ValidationError({"password": "Password must be at least 8 characters long."})

    # Validate mobile number (only digits, 10-15 characters)
    mobile_number = request_data.get("mobile_number", "")
    if not re.fullmatch(r"^\d{10,15}$", mobile_number):
        raise ValidationError({"mobile_number": "Mobile number must be between 10 to 15 digits and contain only digits."})

    # Validate date of birth (if provided, user must be at least 13 years old)
    date_of_birth = request_data.get("date_of_birth")
    if date_of_birth:
        try:
            dob = date.fromisoformat(date_of_birth)  # Ensure it's in "YYYY-MM-DD" format
            today = date.today()
            age = today.year - dob.year - ((today.month, today.day) < (dob.month, dob.day))
            if age < 13:
                raise ValidationError({"date_of_birth": "User must be at least 13 years old."})
        except ValueError:
            raise ValidationError({"date_of_birth": "Invalid date format. Use 'YYYY-MM-DD'."})

    # Validate address fields (if provided, they cannot be empty strings)
    for field in ["street", "city", "country"]:
        if field in request_data and not request_data[field].strip():
            raise ValidationError({field: f"{field.replace('_', ' ').capitalize()} cannot be empty."})

    return request_data  # Return cleaned data if valid
def validate_profile_update(data):
    """
    Validate and filter profile update data.

    - Keeps only allowed keys.
    - Ensures correct data types.
    - Returns (True, valid_data) if valid.
    - Returns (False, errors) if there are invalid fields.
    """

    # Allowed keys and their expected types
    allowed_keys = {
        "bio": str,
        "profile_image": (str, bytes),  # Accept file path or binary image data
        "profession": str,
        "location": str,
        "verified": bool,
    }

    valid_data = {}
    errors = {}

    for key, value in data.items():
        if key in allowed_keys:
            # Check if value matches expected type
            if isinstance(value, allowed_keys[key]):
                valid_data[key] = value
            else:
                errors[key] = f"Expected {allowed_keys[key]}, got {type(value).__name__}."
        else:
            errors[key] = "Invalid field."

    # If errors exist, return False with error messages
    if errors:
        return False, errors

    return True, valid_data  # If everything is valid, return True with filtered data



import pycountry
from geopy.geocoders import Nominatim
from geopy.exc import GeocoderServiceError, GeocoderTimedOut, GeocoderQuotaExceeded

def validate_location(data):
    """
    Validate that the location data contains all required fields,
    ensures the city exists and belongs to the given country,
    and checks for valid latitude and longitude values.

    Returns:
        (True, validated_data) if valid
        (False, error_messages) if invalid
    """
    required_fields = ["city", "country", "latitude", "longitude", "address"]
    errors = {}

    # Check if all required fields are present
    for field in required_fields:
        if field not in data or not data[field]:
            errors[field] = f"{field} is required."

    if errors:
        return False, errors

    city = data["city"].strip()
    country = data["country"].strip()
    latitude = data["latitude"]
    longitude = data["longitude"]
    address = data["address"].strip()
    # Validate latitude and longitude ranges
    try:
        latitude = float(latitude)
        longitude = float(longitude)
        if not (-90 <= latitude <= 90):
            errors["latitude"] = "Latitude must be between -90 and 90."
        if not (-180 <= longitude <= 180):
            errors["longitude"] = "Longitude must be between -180 and 180."
    except ValueError:
        errors["latitude"] = "Latitude must be a valid number."
        errors["longitude"] = "Longitude must be a valid number."

    # Validate that the country exists (by name or ISO alpha-2)
    country_obj = pycountry.countries.get(name=country) or pycountry.countries.get(alpha_2=country.upper())
    if not country_obj:
        errors["country"] = "Invalid country name or code."

    if errors:
        return False, errors

    # Validate that the city exists in the given country
    geolocator = Nominatim(user_agent="your_unique_app_name", timeout=10)
    try:
        location = geolocator.geocode(f"{city}, {country_obj.name}", exactly_one=True)
        if not location:
            errors["city"] = f"Could not find {city} in {country_obj.name}."
    except GeocoderQuotaExceeded:
        errors["geocode"] = "Geocoder rate limit exceeded. Try again later."
    except (GeocoderServiceError, GeocoderTimedOut):
        errors["geocode"] = "Geolocation service unavailable or request timed out."

    if errors:
        return False, errors

    # If all validations pass
    validated_data = {
        "city": city,
        "country": country_obj.name,
        "latitude": latitude,
        "longitude": longitude,
        "address": address
    }
    return True, validated_data



from api.views_main import *


class GroupMembersData(APIView):
    """Retrieve all members of a given group."""
    permission_classes = [IsAuthenticated]  # Require authentication

    def post(self, request):
        """Return all members of the specified group."""
        try:
            group_id = request.data.get("group_id")  # ✅ Corrected data retrieval

            # ✅ Validate group existence
            group = Groups.objects.filter(id=group_id).first()
            if not group:
                return Response({"error": "Group not found"}, status=status.HTTP_404_NOT_FOUND)

            all_objects = []
            groups_members = group.members.all()  # ✅ Corrected member retrieval

            for member in groups_members:
                member_data = {
                    "id":member.id,
                    "first_name": member.first_name,
                    "last_name": member.last_name,
                    "mobile_number": member.mobile_number,
                    "email": member.email,
                    "username": member.username,
                }
                if group.admin_user == member:
                    member_data["admin_user"] = True
                all_objects.append(member_data)

            return Response(all_objects, status=status.HTTP_200_OK)

        except Exception as e:
            return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

class GetUserGroups(APIView):
    """Retrieve all groups the authenticated user belongs to."""
    permission_classes = [IsAuthenticated]  # Require authentication

    def get(self, request):
        """Return all groups the logged-in user is a member of."""
        user = request.user
        groups = Groups.objects.filter(admin_user=user)  # Get groups where user is a member
        serializer = GroupsSerializer(groups, many=True)
        return Response(serializer.data, status=status.HTTP_200_OK)
class CreateGroup(APIView):
    permission_classes = [IsAuthenticated]  # Require authentication

    def post(self, request):
        username = request.data.get("username")
        # password = request.data.get("password")
        group_name = request.data.get("group_name")
        contact_name = request.data.get("contact_name")
        group_description = request.data.get("group_description")

        # Authenticate user
        # user = authenticate(username=username, password=password)
        user = request.user

        if user is None or isinstance(user, AnonymousUser):
            return Response({"error": "Invalid username or password"}, status=S401)

        # Check if user is logged in
        # if not request.user.is_authenticated:
        #     return Response({"error": "User must be logged in"}, status=S403)
        if Groups.objects.filter(name=group_name).exclude(id=group.id).exists():
            return Response({"error": f"The group name '{group_name}' already exists."}, status=S.HTTP_400_BAD_REQUEST)
        # Create new group
        group = Groups.objects.create(
            name=group_name,
            description=group_description,
            admin_user=user  # Assuming the Group model has an 'admin' field
        )
        group_contact =GroupContact.objects.create(user=user, group=group, contact_name = contact_name or user.username)
        group_contact.save()
        group.members.add(user)  # Add user as a member
        return Response({"message": "Group created successfully", "group_id": group.id}, status=S201)


class UpdateGroup(APIView):
    """Allows a group admin to update group details."""

    permission_classes = [IsAuthenticated]  # Only authenticated users can update

    def post(self, request):
        data = request.data
        group_id = data.get("group_id")
        group_name = data.get("group_name")
        update_data = data.get("update_data", {})

        if not group_id and not group_name:
            return Response({"error": "Either 'group_id' or 'group_name' is required."}, status=S.HTTP_400_BAD_REQUEST)

        # Retrieve group using group_id or group_name
        if group_id:
            group = get_object_or_404(Groups, id=group_id)
        else:
            group = get_object_or_404(Groups, name=group_name)

        # Ensure the user is the admin
        if request.user != group.admin_user:
            return Response({"error": "You are not authorized to update this group."}, status=S.HTTP_403_FORBIDDEN)

        # Validate update_data fields
        allowed_fields = {"name", "description"}
        invalid_fields = set(update_data.keys()) - allowed_fields
        if invalid_fields:
            return Response({"error": f"Invalid fields: {', '.join(invalid_fields)}. Allowed fields: {', '.join(allowed_fields)}."}, status=S.HTTP_400_BAD_REQUEST)

        # Check for uniqueness if updating 'name'
        new_name = update_data.get("name")
        if new_name and new_name != group.name:
            if Groups.objects.filter(name=new_name).exclude(id=group.id).exists():
                return Response({"error": f"The group name '{new_name}' already exists."}, status=S.HTTP_400_BAD_REQUEST)

        # Track updates
        updated = False
        unchanged_fields = []

        for field, value in update_data.items():
            if hasattr(group, field):
                if getattr(group, field) != value:
                    setattr(group, field, value)
                    updated = True
                else:
                    unchanged_fields.append(field)

        if updated:
            group.save()
            return Response({"message": "Group updated successfully."}, status=S.HTTP_200_OK)

        # Provide clear reasons for no update
        if not update_data:
            return Response({"error": "No update data provided."}, status=S.HTTP_400_BAD_REQUEST)

        if unchanged_fields:
            return Response({"error": f"No changes detected. Fields already have the same values: {', '.join(unchanged_fields)}."}, status=S.HTTP_400_BAD_REQUEST)

        return Response({"error": "No valid updates were made."}, status=S.HTTP_400_BAD_REQUEST)

class AddUserToGroup(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        group_identifier = request.data.get("group_name") or request.data.get("group_id")
        admin_username = request.data.get("admin_username")
        username = request.data.get("username")
        contact_name = request.data.get("contact_name")

        # Validate input fields
        if not group_identifier or not admin_username or not username or not contact_name:
            return Response({"error": "Missing required fields"}, status=S.HTTP_400_BAD_REQUEST)

        # Check if admin user exists
        admin_user = Users.objects.filter(username=admin_username).first()
        if not admin_user or not admin_user.is_authenticated:
            return Response({"error": "Invalid or unauthenticated admin user"}, status=S.HTTP_401_UNAUTHORIZED)

        # Find the group by ID or name
        group = None
        if isinstance(group_identifier, int):
            group = Groups.objects.filter(id=group_identifier).first()
        else:
            group = Groups.objects.filter(name=group_identifier).first()

        if not group:
            return Response({"error": "Group not found"}, status=S.HTTP_404_NOT_FOUND)

        # Ensure only the group's admin can add users
        if group.admin_user != admin_user:
            return Response({"error": "Only the group admin can add users"}, status=S.HTTP_403_FORBIDDEN)

        # Check if the user to be added exists
        add_user = Users.objects.filter(username=username).first()
        if not add_user:
            return Response({"error": "User to be added not found"}, status=S.HTTP_404_NOT_FOUND)

        # **Check if the user is already a group member**
        if group.members.filter(id=add_user.id).exists():
            return Response({"error": "User is already in the group"}, status=S.HTTP_400_BAD_REQUEST)

        # **Check if contact_name is already in GroupContact for this group**
        if GroupContact.objects.filter(group=group, contact_name=contact_name).exists():
            return Response({"error": "Contact name already exists in the group"}, status=S.HTTP_400_BAD_REQUEST)

        # Add user to group
        group.members.add(add_user)

        # Create GroupContact entry
        group_contact = GroupContact.objects.create(user=add_user, group=group, contact_name=contact_name or add_user.username)
        group_contact.save()

        return Response({"message": f"{username} added to {group.name} successfully as {contact_name}"}, status=S.HTTP_200_OK)
class RemoveUserFromGroup(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        print(f"\n\nrequest header\n\n")
        group_identifier = request.data.get("group_name") or request.data.get("group_id")
        admin_username = request.data.get("admin_username")
        username = request.data.get("username")
        contact_name = request.data.get("contact_name")
        # Validate input
        if not all([group_identifier, admin_username]) or not all(["username, contact_name"]):
            return Response({"error": "Missing required fields"}, status=S400)

        # Check if admin user exists and is authenticated
        admin_user = Users.objects.filter(username=admin_username).first()
        if not admin_user or not admin_user.is_authenticated:
            return Response({"error": "Invalid or unauthenticated admin user"}, status=S401)

        # Find the group by name or ID
        group = None
        if isinstance(group_identifier, int):  # If group_id is given
            group = Groups.objects.filter(id=group_identifier).first()
        else:  # If group_name is given
            group = Groups.objects.filter(name=group_identifier).first()

        if not group:
            return Response({"error": "Group not found"}, status=S404)

        # Check if admin user is the group's admin
        if group.admin_user != admin_user:
            return Response({"error": "Only the group admin can remove users"}, status=S403)

        # Check if the user to be removed exists

        user =None;
        if not username:
            contact = GroupContact.objects.filter(contact_name=contact_name).first()
            user = contact.user
        else:
            user = Users.objects.filter(username=username).first()


        if not user:
            return Response({"error": "User to be removed not found"}, status=S404)

        # Check if the user is in the group
        if user not in group.members.all():
            return Response({"error": "User is not a member of this group"}, status=S400)

        # Remove user from group
        group.members.remove(user)
        return Response({"message": f"{username} removed from {group.name} successfully"}, status=S200)

class GetUpdateGroupContacts(APIView):
    """Handles retrieving and updating group contacts."""
    def post(self, request):
        """
        Fetch group contacts. If `contact_name` is provided, return that contact.
        Otherwise, return all contacts in the group, excluding the admin.
        """
        group_id = request.data.get("group_id")
        contact_name = request.data.get("contact_name")  # Optional

        if not group_id:
            return Response({"error": "group_id is required"}, status=S.HTTP_400_BAD_REQUEST)

        group = get_object_or_404(Groups, id=group_id)
        admin_user = group.admin_user  # Get the admin of the group

        if contact_name:
            # Look for the contact in GroupContact
            contact = GroupContact.objects.filter(group=group, contact_name=contact_name).first()

            if not contact:
                # If contact_name doesn't exist, check if user exists in group
                user = Users.objects.filter(group_memberships__group=group, username=contact_name).first()
                if user:
                    # Return default data for a group member without a contact entry
                    return Response({
                        "contact_name": user.username,  # Default to username
                        "mobile_number": user.mobile_number,
                        "user_id": user.id
                    }, status=S.HTTP_200_OK)
                return Response({"error": "Contact not found"}, status=S.HTTP_404_NOT_FOUND)

            # Return found contact details
            return Response({
                "contact_name": contact.contact_name or contact.user.username,
                "mobile_number": contact.user.mobile_number if contact.user else None,
                "user_id": contact.user.id if contact.user else None
            }, status=S.HTTP_200_OK)

        # If no contact_name is provided, return all contacts in the group, excluding the admin
        contacts = GroupContact.objects.filter(group=group).select_related("user")

        contact_list = [{
            "contact_name": c.contact_name or c.user.username,
            "mobile_number": c.user.mobile_number if c.user else None,
            "user_id": c.user.id if c.user else None
        } for c in contacts if c.user != admin_user]  # Exclude admin from list

        return Response(contact_list, status=S.HTTP_200_OK)

    def put(self, request):
        """Update the contact name of a group member."""
        group_id = request.data.get("group_id")
        user_id = request.data.get("user_id")
        new_contact_name = request.data.get("contact_name")

        if not group_id or not user_id or not new_contact_name:
            return Response({"error": "group_id, user_id, and contact_name are required"}, status=S.HTTP_400_BAD_REQUEST)

        group = get_object_or_404(Groups, id=group_id)
        user = get_object_or_404(Users, id=user_id)

        # Ensure the user is a member of the group
        if user not in group.members.all():
            return Response({"error": "User is not a member of this group"}, status=S.HTTP_403_FORBIDDEN)

        # Find or create a GroupContact instance
        contact, created = GroupContact.objects.get_or_create(user=user, group=group)
        contact.contact_name = new_contact_name
        contact.save()

        return Response({"message": "Contact updated successfully"}, status=S.HTTP_200_OK)from api.views_main import *

class SetLocations(APIView):
    """
    API endpoint for setting, updating, retrieving, and deleting a user's locations.
    Requires authentication.
    """
    permission_classes = [IsAuthenticated]

    def post(self, request):
        """Create a new location for the authenticated user."""
        user = request.user
        data = request.data

        # Ensure required fields are present
        required_fields = {"city", "country", "latitude", "longitude"}
        if not required_fields.issubset(data.keys()):
            return Response({"error": f"Missing required fields: {required_fields - data.keys()}"},
                            status=status.HTTP_400_BAD_REQUEST)

        # Validate location data
        is_valid, result = validate_location(data)
        if not is_valid:
            return Response({"errors": result}, status=status.HTTP_400_BAD_REQUEST)

        # Save the location instance
        location = Locations.objects.create(user=user, **result)
        serializer = LocationsSerializer(location)

        return Response(
            {"message": "Location saved successfully!", "data": serializer.data},
            status=status.HTTP_201_CREATED
        )

    def put(self, request):
        """Update an existing location for the authenticated user."""
        user = request.user
        data = request.data

        location_id = data.get("id")
        if not location_id:
            return Response({"error": "Location ID is required"}, status=status.HTTP_400_BAD_REQUEST)

        try:
            location = Locations.objects.get(id=location_id, user=user)
        except Locations.DoesNotExist:
            return Response({"error": "Location not found"}, status=status.HTTP_404_NOT_FOUND)

        # Validate updated location data
        is_valid, result = validate_location(data)
        if not is_valid:
            return Response({"errors": result}, status=status.HTTP_400_BAD_REQUEST)

        # Update location instance
        for key, value in result.items():
            setattr(location, key, value)
        location.save()

        serializer = LocationsSerializer(location)
        return Response(
            {"message": "Location updated successfully!", "data": serializer.data},
            status=status.HTTP_200_OK
        )

    def delete(self, request, id=None):
        """Delete a specific location by ID (from URL or request data)."""
        user = request.user
        location_id = id or request.data.get("id")

        if not location_id:
            return Response({"error": "Location ID is required"}, status=status.HTTP_400_BAD_REQUEST)

        try:
            location = Locations.objects.get(id=location_id, user=user)
            location.delete()
            return Response({"message": "Location deleted successfully"}, status=status.HTTP_200_OK)
        except Locations.DoesNotExist:
            return Response({"error": "Location not found"}, status=status.HTTP_404_NOT_FOUND)

    def get(self, request, id=None):
        """Retrieve all locations or a specific one by ID."""
        user = request.user
        location_id = id or request.query_params.get("id")

        if location_id:
            try:
                location = Locations.objects.get(id=location_id, user=user)
                serializer = LocationsSerializer(location)
                return Response({"location": serializer.data}, status=status.HTTP_200_OK)
            except Locations.DoesNotExist:
                return Response({"error": "Location not found"}, status=status.HTTP_404_NOT_FOUND)

        # If no ID is provided, return all locations
        locations = Locations.objects.filter(user=user)
        serializer = LocationsSerializer(locations, many=True)
        return Response({"locations": serializer.data}, status=status.HTTP_200_OK)
class RecentLcation(APIView):
    permission_classes = [IsAuthenticated]
    def get(self, request):
        user_id = request.user.id
        try:
            recent_location = Locations.recent(user_id=user_id)
            serializer = LocationsSerializer(recent_location).data
            return Response(serializer, S200)
        except Exception as e:
            return Response({"error":str(e)}, S500)

class DeleteAllLocations(APIView):
    """API endpoint to delete all locations for an authenticated user."""
    permission_classes = [IsAuthenticated]

    def delete(self, request):
        user = request.user
        deleted_count, _ = Locations.objects.filter(user=user).delete()
        return Response({"message": f"Deleted {deleted_count} locations"}, status=status.HTTP_200_OK)

from rest_framework.response import Response
from rest_framework.authentication import SessionAuthentication

from rest_framework.views import APIView
from django.contrib.auth import authenticate, login,  logout
from django.middleware.csrf import get_token
from django.utils.decorators import method_decorator
from django.views.decorators.csrf import ensure_csrf_cookie


from rest_framework.permissions import IsAuthenticated
from rest_framework import permissions, generics
from .models import *
from api.__init__ import *
from .validation import *
from .serializers import *
from django.contrib.auth.models import AnonymousUser
import json
from django.core.exceptions import FieldError
from django.shortcuts import get_object_or_404
ensure_csrf = method_decorator(ensure_csrf_cookie)from api.views_users_management import *
from api.views_groups import *
from api.views_locations import *
from api.views_subscriptions import*

# from twilio.rest import Client

from .utils import send_sms

class SendSMSView(APIView):
    def post(self, request):
        to_phone_number = request.data.get('to_phone_number')
        message = request.data.get('message')

        if not to_phone_number or not message:
            return Response(
                {"error": "Both 'to_phone_number' and 'message' are required."},
                status=status.HTTP_400_BAD_REQUEST
            )

        result = send_sms(to_phone_number, message)

        if result["status"] == "success":
            return Response({"status": "success", "message_sid": result["message_sid"]}, status=status.HTTP_200_OK)
        else:
            return Response({"error": result["error"]}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


import logging
from django.core.mail import send_mail
logger = logging.getLogger(__name__)

class SendEmailToTest(APIView):
    # permission_classes = [IsAuthenticated]
    def get(self, request):
        return Response({"message": "Send a POST request to send an email"}, status=200)
    def post(self, request):
        try:
            # Extract email details from request
            dist_mail = request.data.get("dist_mail", "").strip()
            dist_mail_body = request.data.get("dist_mail_body", "").strip()
            dist_mail_sub = request.data.get("dist_mail_sub", "").strip()

            if not dist_mail or not dist_mail_body or not dist_mail_sub:
                return Response({"error": "All fields are required (dist_mail, dist_mail_body, dist_mail_sub)"}, status=400)

            # Sending email
            x = send_mail(
                subject=dist_mail_sub,
                message=dist_mail_body,
                from_email='coolkatsumi@gmail.com',
                recipient_list=[dist_mail],
                fail_silently=False  # Ensures errors are raised for debugging
            )
            print("\na7a7a7a -3")

            logger.info(f"Email sent successfully to {dist_mail}")
            print("\na7a7a7a -4")

            return Response({"success": bool(x)}, status=200)

        except Exception as e:
            logger.error(f"Email sending failed: {str(e)}")
            return Response({"error": str(e)}, status=500)

# class SendSMS:
#     def __init__(self, account_sid, auth_token, twilio_number):
#         self.client = Client(account_sid, auth_token)
#         self.twilio_number = twilio_number

#     def send(self, receiver_number, message):
#         try:
#             msg = self.client.messages.create(
#                 body=message,
#                 from_=self.twilio_number,
#                 to=receiver_number
#             )
#             return True, f"SMS sent to {receiver_number} (SID: {msg.sid})"
#         except Exception as e:
#             return False, f"Error: {str(e)}"
# # send_sms =  SendSMS()
class SendHelpToGroupMembers(APIView):
    permission_classes = [IsAuthenticated]
    def get(self, request, msg=""):
        if msg:
            request.data["message"] = msg
        return Response(self.members_data(request), S200)
    def post(self, request):

        return Response(self.members_data(request), S200)
    @classmethod
    def members_data(cls, request):
        try:
            msg = "";
            help_msg = request.data.get("message", "")
            # return {"user":request.user.username}
            group = Groups.objects.filter(members=request.user).first()
            members = list(group.members.all());
            members_data = []
            for member in members:
                member_data = {
                    "name":GroupContact.objects.filter(user=member).first().contact_name,
                    "mobile_number": member.mobile_number,
                    "email": member.email,
                    "sender":False
                }
                if request.user.id == member.id:
                    member_data["sender"] = True
                    msg = f"{member_data['name']} is sending"
                    msg +=": " + help_msg if help_msg else "help"
                # else:

                    # send_sms.send(member.mobile_number, sms)
                # if help_msg:
                #     member_data["message"] = help_msg

                members_data.append(member_data)
            for _ in members_data:
                if not _["sender"]:
                    _["help_message"] = msg
                    del _["sender"]
                else:
                    members_data.remove(_)

            return members_data
        except Exception as e:
            return {"error":str(e)}


class EchoRequestView(APIView):
    """An endpoint that returns the full request details and saves them to a file."""

    def handle_request(self, request):
        """Handles any request type and logs all details."""

        # Extract request headers
        headers = {key: value for key, value in request.headers.items()}

        # Extract request body safely
        try:
            body = request.body.decode('utf-8').strip()
            json_body = json.loads(body) if body else {}
        except json.JSONDecodeError:
            json_body = {"error": "Invalid JSON"}

        # Build full request data
        request_data = {
            "method": request.method,
            "path": request.get_full_path(),
            "headers": headers,
            "query_params": request.query_params.dict(),  # Query string params
            "body": json_body,
            "user": str(request.user) if request.user.is_authenticated else "Anonymous",
            "user_agent": headers.get("User-Agent", "Unknown"),
        }

        # Save request details to a JSON file
        with open("test.json", 'w') as log_file:
            json.dump(request_data, log_file, indent=4)

        return Response(request_data)

    # Allow all HTTP methods
    def get(self, request): return self.handle_request(request)
    def post(self, request): return self.handle_request(request)
    def put(self, request): return self.handle_request(request)
    def patch(self, request): return self.handle_request(request)
    def delete(self, request): return self.handle_request(request)

from api.views_main import *
class SubscriptionPackageView(APIView):
    """
    API endpoint for creating, updating, and deleting subscription packages.
    Requires an application admin (superuser) to be logged in
    and to provide a valid admin username & password.
    """
    permission_classes = [IsAuthenticated]

    def authenticate_admin(self, request):
        """Helper function to authenticate an admin user."""
        admin_username = request.data.get("admin_username")
        admin_password = request.data.get("admin_password")
        admin_user = authenticate(username=admin_username, password=admin_password)

        if not admin_user or not admin_user.is_superuser:
            return None

        return admin_user
    def get(self, request):
            """Retrieve all available subscription packages"""
            packages = SubscriptionPackage.objects.all()
            serializer = SubscriptionPackagesSerializer(packages, many=True)
            return Response(serializer.data, status=status.HTTP_200_OK)

    def post(self, request):
        """Create a new subscription package (Only for superusers)."""
        admin_user = self.authenticate_admin(request)
        if not admin_user:
            return Response(
                {"error": "Invalid admin credentials or insufficient permissions"},
                status=status.HTTP_403_FORBIDDEN
            )

        serializer = SubscriptionPackagesSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save(created_by=admin_user)
            return Response(
                {"message": "Subscription package created successfully", "data": serializer.data},
                status=status.HTTP_201_CREATED
            )

        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

    def put(self, request):
        """Update an existing subscription package (Only for superusers)."""
        admin_user = self.authenticate_admin(request)
        if not admin_user:
            return Response(
                {"error": "Invalid admin credentials or insufficient permissions"},
                status=status.HTTP_403_FORBIDDEN
            )

        package_id = request.data.get("id")
        if not package_id:
            return Response({"error": "Subscription package ID is required"}, status=status.HTTP_400_BAD_REQUEST)

        try:
            package = SubscriptionPackage.objects.get(id=package_id)
        except SubscriptionPackage.DoesNotExist:
            return Response({"error": "Subscription package not found"}, status=status.HTTP_404_NOT_FOUND)

        serializer = SubscriptionPackagesSerializer(package, data=request.data, partial=True)
        if serializer.is_valid():
            serializer.save()
            return Response(
                {"message": "Subscription package updated successfully", "data": serializer.data},
                status=status.HTTP_200_OK
            )

        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

    def delete(self, request):
        """Delete a subscription package (Only for superusers)."""
        admin_user = self.authenticate_admin(request)
        if not admin_user:
            return Response(
                {"error": "Invalid admin credentials or insufficient permissions"},
                status=status.HTTP_403_FORBIDDEN
            )

        package_id = request.data.get("id")
        if not package_id:
            return Response({"error": "Subscription package ID is required"}, status=status.HTTP_400_BAD_REQUEST)

        try:
            package = SubscriptionPackage.objects.get(id=package_id)
            package.delete()
            return Response({"message": "Subscription package deleted successfully"}, status=status.HTTP_200_OK)
        except SubscriptionPackage.DoesNotExist:
            return Response({"error": "Subscription package not found"}, status=status.HTTP_404_NOT_FOUND)



from api.views_main import *
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
# Create your views here.
class Hi(APIView):

    def get(self, request):
        return Response(
            {"message":"Help Application Api Routs"} , status=S200
        )

@method_decorator(csrf_exempt, name='dispatch')
class getCSRFCookie(APIView):
    def get(self, request):
        csrf_token = get_token(request)
        return JsonResponse({"csrf_token": csrf_token})

class Register(APIView):
    def post(self, request):
        clean_data = validate_user_data(request.data)

        # Extract password before passing to model
        password = clean_data.pop("password", None)
        username = clean_data.get("username")
        email = clean_data.get("email")
        mobile_number = clean_data.get("mobile_number")

        # Check if the username or email already exists
        if Users.objects.filter(username=username).exists():
            return Response({"error": "Username already exists"}, status=status.HTTP_400_BAD_REQUEST)

        if Users.objects.filter(email=email).exists():
            return Response({"error": "Email already exists"}, status=status.HTTP_400_BAD_REQUEST)
        if Users.objects.filter(mobile_number=mobile_number).exists():
            return Response({"error": "mobile_number already exists"}, status=status.HTTP_400_BAD_REQUEST)
        # Create user instance (without password)
        user = Users(**clean_data)

        # Hash the password properly
        if password:
            user.set_password(password)  # 🔑 Hashes the password

        user.is_active = False;
        user.save()  # Now the password is securely stored

        # 🔹 Create the Profile instance for the user
        Profile.objects.create(user=user)

        # Serialize the user object using UsersSerializer
        serializer = UsersSerializer(user, context={"request": request}).data
        verification = VerificationCode.objects.create(user=user)

        # Write serialized data to test.json for debugging
        return Response({
            "user": serializer,
            "verification_code": verification.code,  # Return Verification Code in Response
            "message": "User registered successfully. Please verify your code.",
            "is_active":user.is_active
        }, status=200)

class GetVerificationCode(APIView):
    def post(self, request):
        username = request.data.get("username")
        mobile_number = request.data.get("mobile_number")

        if not username or not mobile_number:
            return Response(
                {"error": "Username and Mobile Number are required"},
                status=status.HTTP_400_BAD_REQUEST
            )

        try:
            user = Users.objects.get(username=username, mobile_number=mobile_number)
        except Users.DoesNotExist:
            return Response(
                {"error": "Invalid Username or Mobile Number"},
                status=status.HTTP_400_BAD_REQUEST
            )

        # Clear expired codes before generating new one
        VerificationCode.clear_codes(user=user)

        # Generate new verification code
        verification_code = VerificationCode.objects.create(user=user)

        return Response(
            {
                "message": "Verification code generated successfully",
                "code": verification_code.code,  # ✅ Show the code (Only for testing)
                "expire_at": verification_code.expire_date.strftime("%Y-%m-%d %H:%M:%S"),
            },
            status=status.HTTP_200_OK
        )

class ActivateAccount(APIView):
    def post(self, request):
        username = request.data.get("username")
        code = request.data.get("code")

        if not username or not code:
            return Response({"error": "Username and Verification Code are required"}, status=status.HTTP_400_BAD_REQUEST)

        try:
            user = Users.objects.get(username=username)
            verification = VerificationCode.objects.get(user=user, code=code)
        except (Users.DoesNotExist, VerificationCode.DoesNotExist):
            return Response({"error": "Invalid Username or Verification Code"}, status=status.HTTP_400_BAD_REQUEST)

        if verification.is_used:
            return Response({"error": "This verification code is already used"}, status=status.HTTP_400_BAD_REQUEST)

        # Here 🔥
        if timezone.now() > verification.expire_date:
            return Response({"error": "Verification code has expired"}, status=status.HTTP_400_BAD_REQUEST)

        user.is_active = True
        user.save()

        verification.is_used = True
        verification.save()

        return Response({"message": "Account activated successfully"}, status=status.HTTP_200_OK)

class Login(APIView):
    permission_classes = (permissions.AllowAny,)
    authentication_classes = (SessionAuthentication,)
    def post(self, request):
        username = request.data.get("username")
        password = request.data.get("password")

        # Check if both fields are provided
        if not username or not password:
            return Response({"error": "Username and password are required"}, status=S400)

        # Authenticate user
        user = authenticate(username=username, password=password)

        user_q = Users.objects.filter(username=username).first()
        if not user_q.is_active:
            return Response({"error":"please activate your account"}, S401)
        if user:
            login(request, user)  # Start session

            # Get CSRF token
            # csrf_token = get_token(request)

            # Create response
            return  Response(
                {"message": "Login successful", "user": {"username": user.username}},
                status=S200
            )

            # # Set session ID and CSRF token in cookies
            # response.set_cookie(key="sessionid", value=request.session.session_key, httponly=True, secure=False, samesite="Lax")
            # response.set_cookie(key="csrftoken", value=csrf_token, secure=False, samesite="Lax")

            # return response
        else:
            return Response({"error": "Invalid credentials"}, status=S401)

class Logout(APIView):
    permission_classes = (permissions.AllowAny,)
    authentication_classes = ()

    def post(self, request):
        logout(request)
        return Response(status=S200)

class CreateGroup(APIView):
    permission_classes = [IsAuthenticated]

class ProfileView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        try:
            username = request.data.get("username")
            user = Users.objects.filter(username=username).first()
            profile = Profile.objects.filter(user=user).first()
            serialized_profile = ProfileSerializer(profile, context={"request": request})
            return Response(
                serialized_profile, status=S200
            )
        except Exception as e:
            return Response(
                {"error":str(e)}, status=S500
            )


class DeleteUser(APIView):
    # permission_classes = [IsAuthenticated]

    def post(self, request):
        username = request.data.get("username")
        password = request.data.get("password")

        # Validate input
        if not username or not password:
            return Response({"error": "Username and password are required"}, status=S400)

        # Authenticate user
        user = authenticate(username=username, password=password)
        if not user:
            return Response({"error": "Invalid credentials"}, status=S401)

        # Ensure the user is deleting their own account
        if request.user != user:
            return Response({"error": "login  required"}, status=S403)

        # Log out the user if they are authenticated
        logout(request)

        # Delete user account
        user.delete()

        return Response({"message": "Account deleted successfully"}, status=S200)
class GetUserData(APIView):
    permission_classes = [IsAuthenticated]  # Ensure authentication is required

    def post(self, request):
        # Extract username and password from request body
        username = request.data.get("username")
        password = request.data.get("password")

        if not username or not password:
            return Response({"error": "Username and password are required."}, status=400)

        # Authenticate the user
        user = authenticate(username=username, password=password)

        if user is None:
            return Response({"error": "Invalid credentials."}, status=401)

        # Ensure the authenticated user matches the logged-in user
        if request.user != user:
            return Response({"error": "Unauthorized access."}, status=403)

        # Fetch user and profile data
        user_data = UsersSerializer(user).data
        profile = Profile.objects.filter(user=user).first()
        profile_data = ProfileSerializer(profile).data if profile else {}

        return Response({
            "user": user_data,
            "profile": profile_data
        })
class UserUpdate(APIView):
    permission_classes = [IsAuthenticated]  # Ensure only authenticated users can access

    def put(self, request):
        # Extract username, password, and update_data from request body
        username = request.data.get("username")
        password = request.data.get("password")

        # Data To Update
        update_data = request.data.get("update_data", {})
        N_username = update_data.get("username", "")
        N_email = update_data.get("email", "")
        N_mobile_number = update_data.get("mobile_number", "")

        if not username or not password:
            return Response({"error": "Username and password are required."}, status=S400)

        if not update_data:
            return Response({"error": "No update data provided."}, status=S400)

        # Authenticate the user
        user = authenticate(username=username, password=password)

        if user is None:
            return Response({"error": "Invalid credentials."}, status=S401)

        # Ensure the authenticated user matches the logged-in user
        if request.user != user:
            return Response({"error": "Unauthorized access."}, status=S403)
        if Users.objects.filter(username=N_username).exists():
            return Response({"error": f"Username{N_username} already exists"}, status=status.HTTP_400_BAD_REQUEST)

        if Users.objects.filter(email=N_email).exists():
            return Response({"error": f"Email {N_email}already exists"}, status=status.HTTP_400_BAD_REQUEST)
        if Users.objects.filter(mobile_number=N_mobile_number).exists():
            return Response({"error": f"mobile_number{N_mobile_number} already exists"}, status=status.HTTP_400_BAD_REQUEST)
        try:
            # Validate the update data
            cleaned_data = validate_user_data(update_data)
        except ValidationError as e:
            return Response({"error": e.detail}, status=S400)

        # Check if password is being updated
        new_password = cleaned_data.pop("password", None)

        # Update user fields
        for field, value in cleaned_data.items():
            setattr(user, field, value)

        # Handle password update separately
        if new_password:
            user.set_password(new_password)
            user.save()
            logout(request)  # Log out the user after password change
            return Response({"message": "Password updated successfully. Please log in again."}, status=S200)
        user.is_active = False
        user.save()

        # Serialize and return updated user data
        serializer = UsersSerializer(user)
        return Response({"message": "User data updated successfully.", "user": serializer.data}, status=S200)

class ProfileUpdate(APIView):
    """ Profile Update Endpoint Class """
    permission_classes = [IsAuthenticated]  # Ensure only authenticated users can access

    def put(self, request):
        is_valid, result = validate_profile_update(request.data)
        if not is_valid:
            return Response(result, status=S400)

        profile = Profile.objects.filter(user=request.user).first()
        if not profile:
            try:
                profile = Profile.objects.create(user=request.user)
            except Exception as e:
                return Response({"error": str(e)}, status=S500)

        # Handle profile image upload
        if 'profile_image' in request.FILES:
            profile.profile_image = request.FILES['profileimg']

        # Update other fields
        for field, value in result.items():
            setattr(profile, field, value)
        profile.save()

        serializer = ProfileSerializer(profile)
        return Response(serializer.data, status=S200)

class profileUpdate_(APIView):
    """ Pofile Update Endpoint Class"""
    permission_classes = [IsAuthenticated]  # Ensure only authenticated users can access
    def put(self, request):
        is_valid , result = validate_profile_update(request.data)
        if not is_valid:
            return Response(result, S400)
        # if request.user.is_auth:
        #     return Response({"error": "Unauthorized access."}, status=S403)

        profile = Profile.objects.filter(user=request.user).first()
        if not profile:
            try:
                profile = Profile.objects.create(user=request.user)
            except Exception as e:
                return Response({"error":str(e)}, S500)
        for field, value in result.items():
            setattr(profile, field, value)
        profile.save()
        serializer = ProfileSerializer(profile).data
        return Response(serializer, S200)


"""
class Search(APIView):
    permission_classes = [IsAuthenticated]
    def post(self, request):
        # try:
        category = request.data.get("category")
        key = request.data.get("key")
        value = request.data.get("value")

        category = category.lower()
        query = {key:value}

        if category not in classes.keys():
            return Response({"errror":f"category {category} is not exxist "}, S404)
        if category in ["user", "users"]:
            user = Users.objects.filter(**query).first()
            if not user:
                return Response({"error":f"cant find user {value}"}, status=S404)
            if request.user != user:
                return Response({"error": "not authorized"}, status=S401)
            serial_user = UsersSerializer(user, context={"request": request}).data
            print(f"\n\n\n {serial_user} \n\n\n")

            return Response(serial_user, status=S200)
        # try:
        Class = classes[category]
        ClassSerializor = classesSerializers[category]
        queryObjt = Class.objects.filter(**query).first()
        serializedObject = ClassSerializor(queryObjt, context={"request":request})
        return Response(serializedObject, S200)
        # except Exception as e:
            # return Response({"error":str(e)})
        # except Exception as e:
        #     return Response({"error":str(e)}, S400)
"""

'''
class Search(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        category = request.data.get("category", "").lower()
        key = request.data.get("key")
        value = request.data.get("value")

        if not category or not key or value is None:
            return Response({"error": "Missing required fields (category, key, or value)."}, S400)

        search_methods = {
            "user": self.search_user,
            "users": self.search_user,
            "profile": self.search_profile,
            "profiles": self.search_profile,
            "group": self.search_group,
            "groups": self.search_group,
            "message": self.search_message,
            "messages": self.search_message,
        }

        if category not in search_methods:
            return Response({"error": f"Category '{category}' does not exist."}, S404)

        return search_methods[category](request, key, value)

    def search_user(self, request, key, value):
        """Search for a user, ensuring the requester can only access their own data."""
        try:
            user = Users.objects.filter(**{key: value}).first()
            if not user:
                return Response({"error": f"User '{value}' not found."}, S404)

            if request.user != user:
                return Response({"error": "Not authorized to view this user."}, S403)

            serialized_user = UsersSerializer(user, context={"request": request}).data
            return Response(serialized_user, S200)
        except FieldError:
            return Response({"error": f"Invalid search key '{key}' for Users."}, S400)

    def search_profile(self, request, key, value):
        """Search for a profile linked to the requesting user."""
        try:
            profile = Profile.objects.filter(user=request.user, **{key: value}).first()
            if not profile:
                return Response({"error": f"Profile '{value}' not found."}, S404)

            serialized_profile = ProfileSerializer(profile, context={"request": request}).data
            return Response(serialized_profile, S200)
        except FieldError:
            return Response({"error": f"Invalid search key '{key}' for Profile."}, S400)

    def search_group(self, request, key, value):
        """Search for a group (users can search for groups they belong to)."""
        try:
            group = Groups.objects.filter(members=request.user, **{key: value}).first()
            if not group:
                return Response({"error": f"Group '{value}' not found or you are not a member."}, S404)

            serialized_group = GroupsSerializer(group, context={"request": request}).data
            return Response(serialized_group, S200)
        except FieldError:
            return Response({"error": f"Invalid search key '{key}' for Group."}, S400)

    def search_message(self, request, key, value):
        """Search for messages where the requester is the sender or receiver."""
        try:
            message = Message.objects.filter(
                sender=request.user, **{key: value}
            ).first() or Message.objects.filter(
                receiver=request.user, **{key: value}
            ).first()

            if not message:
                return Response({"error": f"Message '{value}' not found."}, S404)

            serialized_message = MessageSerializer(message, context={"request": request}).data
            return Response(serialized_message, S200)
        except FieldError:
            return Response({"error": f"Invalid search key '{key}' for Message."}, S400)

'''